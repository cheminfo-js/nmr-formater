{"version":3,"sources":["webpack:///nmr-range/webpack/universalModuleDefinition","webpack:///nmr-range/webpack/bootstrap 7f53cc15b30a53a3cb31","webpack:///nmr-range/./src/index.js","webpack:///nmr-range/./src/oldFormater.js","webpack:///nmr-range/./src/prediction2Range.js"],"names":[],"mappings":"AAAA,cACA,2BACA,uCACA,sCACA,cACA,GACA,0CAEA,eACA,GAAC,mBACD,kBCTA,cAMA,MACA,eAGA,mBACA,SACA,MACA,EAIA,kDAGA,KAGA,YACA,OAIA,OAzBA,cA4BA,MAGA,MAGA,yBCtCA,CAKA,oCA+NA,CACA,UACA,eACA,SAAiB,IAAyB,MAC1C,IACA,UAEA,oBAEA,GACA,IACA,QACA,OAEA,GACA,CAEA,kBACA,CACA,sBACA,iBAEA,aACA,aACA,cACA,OACA,sCACA,cAEA,OACA,SAEA,OAEA,QACK,OACL,gBACK,OACL,oBAEA,SAEA,gBACA,IACA,iBACA,OACA,uCAGA,UAEA,QACA,KACA,qCAGA,QAEA,gBACA,MACA,4DAGA,qBAGA,MAGA,4CACA,iBACA,KACA,gCAEA,iCAGA,eACA,WAIA,iBACA,mBAEA,aACA,0BAIA,GAQA,gBAGA,GACA,KACA,KACA,OACA,KAGA,GACA,uBAGA,IAEA,cACA,GACA,gBACA,SACK,kBACL,WACA,6BAEA,KAEA,cACA,aACA,eACA,qBAGA,4BACA,aACA,qBAGA,YAEA,cACA,aACA,iBACA,SACK,6BACL,eACA,mBAEA,aAEA,gBACA,IACA,gFACA,uBACA,IACA,gBAAqB,MAAa,WAClC,sBACA,mBACA,mBACA,EACA,CACA,SACA,KACA,CAEA,cACA,+BACA,6CACA,aACA,CAEA,cACA,+BACA,iBACA,CAEA,cACA,+BACA,iBACA,CAEA,aACA,sBACA,WAEA,KAEA,aACA,kCACA,cAvZA,KACA,KAEA,GAEA,iBAEA,+BACA,WAAiB,MAAiB,OAClC,gBACA,KAAqB,aAAuB,WAC5C,gBACA,2BACA,gBACA,aAA6B,eAC7B,2BAEA,YACA,CAGA,OACA,EAEA,yCACA,iBACA,EACA,WACA,cACA,IACA,QAAkB,MAAoB,OACtC,uBAEA,cACA,CACA,OAAc,MAAoB,OAClC,mBAGA,QACA,EAEA,8BACA,QAGA,KAFA,mBAA8B,IAAE,yBAA4B,GAC5D,OACgB,WAChB,QACA,sBACA,sDAEA,iBACA,EAQA,qCACA,UACA,OACA,SACA,OACA,4BACA,uBAEA,QACA,UACA,sBAAoB,WACpB,wBACA,wBAGA,EAEA,OACA,UACA,sBAAoB,WACpB,wBACA,wBAGA,EAGA,iBACA,WACA,cACA,OAAgB,IAChB,aACA,OAGA,QACA,iBACA,MAGA,iBAAgB,WAAe,IAC/B,SACA,mBACA,0BACA,0BACA,MACA,4BAAkC,MAClC,YACA,6DAIA,6CACA,QAAkC,MAClC,YACA,qDAMA,IACA,CAEA,QAAY,MACZ,EAEA,sCACA,uDACA,EAEA,mCACA,QACA,UAAgB,WAChB,gBACA,OAAoB,kBACpB,2BAGA,YACA,EAEA,+BAEA,iCAEA,YACA,wBAGA,sBAEA,KACA,KAEA,SACA,iBACA,cACA,sBACA,wBAEA,wBACA,8BACA,iBACA,IAGA,uBACA,iBACA,IAGA,UACA,cACA,8BAEA,MACA,+BAGA,mBAEA,KACA,CAEA,mCAEA,OACA,KAgCA,gBCnOA,CAMA,kCAyCA,CACA,QACA,eACA,SAAiB,IAAyB,MAC1C,IACA,UAEA,oBAEA,GACA,IACA,QACA,OAEA,GACA,CAEA,gBACA,CACA,yBACA,oBAEA,aACA,gBACA,cACA,UACA,yCACA,cAEA,OACA,SAEA,OAEA,QACK,OACL,gBACK,OACL,oBAEA,SAEA,gBAEA,eACA,iBACA,OACA,iEAGA,uBAEA,qBACA,KACA,+DAGA,qBAEA,MACA,SACA,yCAGA,YAGA,gDACA,2CACA,KACA,gCAEA,mCAGA,KACA,sBAIA,MACA,oBAEA,uCACA,0BAIA,GAQA,gBAEA,GACA,KACA,KACA,OACA,KAGA,GACA,uBAEA,IAEA,cACA,GACA,gBACA,SACK,kBACL,eACA,uCAEA,KAEA,cACA,GACA,eACA,WAGA,kBACA,aACA,WAGA,YAEA,cACA,GACA,iBACA,SACK,mBACL,eACA,SAEA,aAEA,gBACA,YACA,WACA,gBAAqB,YAAqB,WAC1C,kBACA,0BACA,mBACA,EACA,CACA,SACA,KAEA,CAEA,cACA,+BACA,6CACA,aACA,CAEA,cACA,+BACA,iBACA,CAEA,cACA,+BACA,iBACA,CAEA,aACA,sBACA,WAEA,KAEA,aACA,kCACA,YA7NA,KAEA,GAEA,kCACA,GACA,KAEA,SACA,iBACA,cACA,sBACA,wBAEA,wBACA,8BACA,mBACA,MAGA,uBACA,mBACA,MAKA,UACA,WACA,8BACK,GACL,gCAGA,mBAEA,KACA,CAEA,gBC3CA,CAGA,sBAAwB,sBAExB,8CACA,uBAAoC,KAEpC,OACA,eACA,mBACA,QAAe,IAAkB,EACjC,kBACA,2BAMA,sBAHA,uBAIA,aAEA,cAAc,MAAoB,WAClC,UACA,UACA,MACA,MACA,EACA,QAAsB,MAAe,OACrC,YAIA,oBAEA,eAEA,gBAAqB,aACrB,aACA,WACA,cACA,QAAkB,MAAmB,OACrC,yBACA,UAEA,UAEA,OAAgB,MAAmB,OACnC,uCACA,6BACA,4BACA,eAAmC,IAAO,EAE1C,mCACA,4CACA,sCACA,oCACA,qCACA,oDACA,eACA,cACA,wBACA,4BAKA,WACA,E","file":"nmr-range.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrRange\"] = factory();\n\telse\n\t\troot[\"nmrRange\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7f53cc15b30a53a3cb31\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\nvar old = require(\"./oldFormater\");\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports = require(\"./prediction2Range\");\n\nmodule.exports.update = function(ranges){\n    for (var i=0; i<ranges.length; i++){\n        var range = ranges[i];\n        for (var j=0; j<range.signal.length; j++){\n            var signal = range.signal[j];\n            if (signal.j && ! signal.multiplicity) {\n                signal.multiplicity = \"\";\n                for (var k=0; k<signal.j.length;k++){\n                    signal.multiplicity+=signal.j[k].multiplicity;\n                }\n            }\n        }\n    }\n\n    return ranges;\n}\n\nmodule.exports.updateIntegrals = function(signals, options) {\n    var  factor = options.factor || 1 ;\n    var i;\n    if(options.sum) {\n        var nH = options.sum || 1;\n        var sumObserved=0;\n        for(i = 0; i < signals.length; i++) {\n            sumObserved += Math.round(signals[i].integral);\n        }\n        factor = nH/sumObserved;\n    }\n    for(i = 0; i < signals.length; i++) {\n        signals[i].integral *= factor;\n    }\n\n    return signals;\n}\n\nmodule.exports.nmrJ = function(Js, options){\n    var Jstring = \"\";\n    var opt = Object.assign({},{separator:\", \", nbDecimal:2}, options);\n    var j;\n    for(var i=0;i<Js.length;i++){\n        j = Js[i];\n        if (j.length>11) j+=opt.separator;\n        Jstring+=j.multiplicity+\" \"+j.coupling.toFixed(opt.nbDecimal);\n    }\n    return Jstring;\n}\n/**\n * This function converts an array of peaks [{x, y, width}] in a vector equally x,y vector\n * TODO This function is very general and should be placed somewhere else\n * @param peaks\n * @param opt\n * @returns {{x: Array, y: Array}}\n */\nmodule.exports.peak2Vector=function(peaks, opt){\n    var options = opt||{};\n    var from = options.from;\n    var to = options.to;\n    var nbPoints = options.nbPoints||16*1024;\n    var fnName = options.fnName||\"gaussian\";\n    var nWidth = options.nWidth || 4;\n\n    if(!from){\n        from = Number.MAX_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x-peaks[i].width*nWidth<from){\n                from = peaks[i].x-peaks[i].width*nWidth;\n            }\n        }\n    }\n\n    if(!to){\n        to = Number.MIN_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x+peaks[i].width*nWidth>to){\n                to = peaks[i].x+peaks[i].width*nWidth;\n            }\n        }\n    }\n\n\n    var x = new Array(nbPoints);\n    var y = new Array(nbPoints);\n    var dx = (to-from)/(nbPoints-1);\n    for(var i=0;i<nbPoints;i++){\n        x[i] = from+i*dx;\n        y[i] = 0;\n    }\n\n    var intensity = \"intensity\";\n    if(peaks[0].y){\n        intensity=\"y\";\n    }\n\n    for(var i=0;i<peaks.length;i++){\n        var peak = peaks[i];\n        if(peak.x>from && peak.x<to){\n            var index = Math.round((peak.x-from)/dx);\n            var w = Math.round(peak.width*nWidth/dx);\n            if(fnName==\"gaussian\"){\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=peak[intensity]*Math.exp(-0.5*Math.pow((peak.x-x[j])/(peak.width/2),2));\n                    }\n                }\n            }else{\n                var factor = peak[intensity]*Math.pow(peak.width,2)/4;\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=factor/(Math.pow(peak.x-x[j],2)+Math.pow(peak.width/2,2));\n\n                    }\n                }\n            }\n\n        }\n    }\n\n    return {x:x,y:y};\n}\n\nmodule.exports.range2Vector=function(ranges, opt){\n    return module.exports.peak2Vector(module.exports.range2Peaks(ranges), opt);\n}\n\nmodule.exports.range2Peaks = function(ranges){\n    var peaks = [];\n    for(var i=0;i<ranges.length;i++){\n        var range = ranges[i];\n        for(var j=0;j<range.signal.length;j++){\n            peaks=peaks.concat(range.signal[j].peak);\n        }\n    }\n    return peaks;\n}\n\nmodule.exports.toACS = function(spectrumIn, options){\n\n    var spectrum = JSON.parse(JSON.stringify(spectrumIn));\n\n    if(spectrum[0].delta1){//Old signals format\n        return old.toACS(spectrum, options);\n    }\n\n    spectrum = module.exports.update(spectrum);\n\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.from- a.from\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.from- b.from\n        });\n    }\n\n    spectrum.type=\"NMR SPEC\";\n    if (options&&options.nucleus==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent, options);\n    }\n    if (options&&options.nucleus==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent,options);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nmodule.exports.toNMRSignal = function(acsString){\n    //TODO Create the function that reconstructs the signals from the ACS string\n    return null;\n}\n\n/*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n appendSeparator();\n appendSpectroInformation(spectra);\n if (spectra[\"peakLabels\"]) {\n var numberPeakLabels=spectra[\"peakLabels\"].length;\n var minIntensity= 9999999;\n var maxIntensity=-9999999;\n for (var i=0; i<numberPeakLabels; i++) {\n if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n }\n for (var i=0; i<numberPeakLabels; i++) {\n if (ascending) {\n var peakLabel=spectra[\"peakLabels\"][i];\n } else {\n var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n }\n if (peakLabel) {\n appendSeparator();\n appendValue(peakLabel,decimalValue);\n if (smw) { // we need to add small / medium / strong\n if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n else acsString+=\" (m)\";\n }\n }\n }\n }\n }*/\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent, options) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent, options);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent, options) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (options.nucleus) {\n            acsString+=formatNucleus(options.nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (options.observe)) {\n            acsString+=\" (\";\n            if (options.observe) {\n                acsString+=(options.observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    var startX = 0,stopX=0,delta1=0, asymmetric;\n    if(line.from){\n        if((typeof line.from)==\"string\"){\n            startX=parseFloat(line.from);\n        }\n        else\n            startX=line.from;\n    }\n    if(line.to){\n        if((typeof line.to)==\"string\"){\n            stopX=parseFloat(line.to);\n        }\n        else\n            stopX=line.to;\n    }\n    if(line.signal[0].delta){\n        if((typeof line.signal[0].delta)==\"string\"){\n            delta1=parseFloat(line.signal[0].delta);\n        }\n        else\n            delta1=line.signal[0].delta;\n    }\n    else{\n        asymmetric = true;\n    }\n    //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n    if (asymmetric===true||(line.signal[0].multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.from&&line.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n            }\n        } else {\n            if(line.signal[0].delta)\n                acsString+=\"?\";\n        }\n    }\n    else{\n        if(line.signal[0].delta)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.from&&line.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    //console.log(\"appendParenthesis1\");\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n    //console.log(\"appendParenthesis2\");\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integral) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integral.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.signal[0].pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.signal[0].pubAssignment);\n    }\n    else{\n        if (line.signal[0].assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.signal[0].assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.signal[0].pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.signal[0].multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.signal[0].multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (\"sm\".indexOf(line.signal[0].multiplicity) < 0\n            && line.signal[0].j && line.signal[0].j.length > 0) {\n        var Js = line.signal[0].j;\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<Js.length; i++) {\n            var coupling=Js[i].coupling || 0;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports.toACS = function(spectrum, options){\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.delta1- a.delta1\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.delta1- b.delta1\n        });\n    }\n\n    //console.log(\"Range1: \"+options.rangeForMultiplet);\n\n    spectrum.type=\"NMR SPEC\";\n    if (spectrum[0][\"nucleus\"]==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent);\n    } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (spectrum[0].nucleus) {\n            acsString+=formatNucleus(spectrum[0].nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (spectrum[0].observe)) {\n            acsString+=\" (\";\n            if (spectrum[0].observe) {\n                acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    //console.log(line);\n    var startX = 0,stopX=0,delta1=0;\n    if(line.integralData.from) {\n        if ((typeof line.integralData.from) == \"string\") {\n            startX = parseFloat(line.integralData.from);\n        }\n        else\n            startX = line.integralData.from;\n    }\n    if(line.integralData.to){\n        if((typeof line.integralData.to)==\"string\"){\n            stopX=parseFloat(line.integralData.to);\n        }\n        else\n            stopX=line.integralData.to;\n    }\n    if(line.delta1){\n        if((typeof line.delta1)==\"string\"){\n            delta1=parseFloat(line.delta1);\n        }\n        else\n            delta1=line.delta1;\n\n    }\n    if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.integralData.from&&line.integralData.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+sttotoFixed(nbDecimal);\n            }\n        } else {\n            if(line.delta1)\n                acsString+=delta1.toFixed(nbDecimal);\n        }\n    }\n    else{\n        if(line.delta1)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.integralData.from&&line.integralData.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integralData) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.pubAssignment);\n    }\n    else{\n        if (line.assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (line.nmrJs) {\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<line.nmrJs.length; i++) {\n            var coupling=line.nmrJs[i].coupling;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oldFormater.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/17/16.\n */\n'use strict';\n\n//lineWidth in Hz frequency in MHz\nconst defaultOptions = {lineWidth:1, frequency: 400};\n\nmodule.exports.prediction2Ranges = function(predictions, opt){\n    const options = Object.assign({}, defaultOptions, opt);\n    //1. Collapse all the equivalent predictions\n    const nPredictions = predictions.length;\n    const ids = new Array(nPredictions);\n    var i, j, diaIDs, prediction, width, center, jc;\n    for(i = 0 ; i < nPredictions; i++) {\n        if(!ids[predictions[i].diaIDs[0]]) {\n            ids[predictions[i].diaIDs[0]] = [i]\n        }\n        else{\n            ids[predictions[i].diaIDs[0]].push(i);\n        }\n    }\n    const idsKeys = Object.keys(ids);\n    const result = new Array(idsKeys.length);\n\n    for(i = 0; i < idsKeys.length; i++) {\n        diaIDs = ids[idsKeys[i]];\n        prediction = predictions[diaIDs[0]];\n        width = 0;\n        jc = prediction.j;\n        if(jc){\n            for(j = 0; j < jc.length; j++) {\n                width+=jc[j].coupling;\n            }\n        }\n\n        width+= 2*options.lineWidth;//Add 2 times the spectral lineWidth\n\n        width/=options.frequency;\n\n        result[i] = {from: prediction.delta-width,\n                    to:prediction.delta+width,\n                    integral:1,\n                    signal:[ predictions[diaIDs[0]] ]};\n        for(j = 1; j < diaIDs.length; j++) {\n            result[i].signal.push(predictions[diaIDs[j]]);\n            result[i].integral++;\n        }\n    }\n    //2. Merge the overlaping ranges\n    for(i  =  0; i < result.length; i++) {\n        result[i]._highlight = result[i].signal[0].diaIDs;\n        center = (result[i].from + result[i].to)/2;\n        width = Math.abs(result[i].from - result[i].to);\n        for(j  = result.length - 1; j > i; j--) {\n            //Does it overlap?\n            if(Math.abs(center - (result[j].from + result[j].to)/2)\n                <= Math.abs(width + Math.abs(result[j].from - result[j].to))/2){\n                result[i].from = Math.min(result[i].from, result[j].from);\n                result[i].to = Math.max(result[i].to, result[j].to);\n                result[i].integral = result[i].integral + result[j].integral;\n                result[i]._highlight.push(result[j].signal[0].diaIDs[0]);\n                result.splice(j,1);\n                j = result.length - 1;\n                center = (result[i].from + result[i].to)/2;\n                width = Math.abs(result[i].from - result[i].to);\n            }\n        }\n    }\n\n    return result;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/prediction2Range.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}