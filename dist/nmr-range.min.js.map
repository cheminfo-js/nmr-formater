{"version":3,"sources":["webpack:///nmr-range/webpack/universalModuleDefinition","webpack:///nmr-range/nmr-range.min.js","webpack:///nmr-range/webpack/bootstrap 0f5cf52f2f822662a89e","webpack:///nmr-range/./src/index.js","webpack:///nmr-range/./src/oldFormater.js","webpack:///nmr-range/./src/prediction2Range.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","formatAcs_default","spectra","ascending","decimalValue","decimalJ","solvent","options","appendSeparator","appendSpectroInformation","numberSmartPeakLabels","length","i","signal","appendDelta","appendParenthesis","spectrum","type","nucleus","acsString","formatNucleus","observe","toFixed","formatMF","line","nbDecimal","asymmetric","startX","stopX","delta1","from","parseFloat","to","delta","multiplicity","rangeForMultiplet","parenthesis","appendMultiplicity","appendIntegration","appendCoupling","appendAssignment","pubIntegration","appendParenthesisSeparator","integral","pubAssignment","formatAssignment","assignment","pubMultiplicity","indexOf","j","Js","coupling","replace","mf","match","old","spectro","update","ranges","range","k","updateIntegrals","signals","factor","sum","nH","sumObserved","Math","round","nmrJ","Jstring","opt","Object","assign","separator","peak2Vector","peaks","nbPoints","fnName","nWidth","Number","MAX_VALUE","x","width","MIN_VALUE","Array","y","dx","intensity","peak","index","w","exp","pow","range2Vector","range2Peaks","concat","toACS","spectrumIn","JSON","parse","stringify","undefined","sort","a","b","toNMRSignal","integralData","sttotoFixed","value","nmrJs","defaultOptions","lineWidth","frequency","prediction2Ranges","predictions","nPredictions","ids","diaIDs","prediction","center","jc","push","idsKeys","keys","result","_highlight","abs","min","max","splice"],"mappings":"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","file":"nmr-range.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrRange\"] = factory();\n\telse\n\t\troot[\"nmrRange\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrRange\"] = factory();\n\telse\n\t\troot[\"nmrRange\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\tvar old = __webpack_require__(1);\n\t\n\tvar acsString=\"\";\n\tvar parenthesis=\"\";\n\tvar spectro=\"\";\n\tvar rangeForMultiplet=false;\n\t\n\tmodule.exports = __webpack_require__(2);\n\t\n\tmodule.exports.update = function(ranges){\n\t    for (var i=0; i<ranges.length; i++){\n\t        var range = ranges[i];\n\t        for (var j=0; j<range.signal.length; j++){\n\t            var signal = range.signal[j];\n\t            if (signal.j && ! signal.multiplicity) {\n\t                signal.multiplicity = \"\";\n\t                for (var k=0; k<signal.j.length;k++){\n\t                    signal.multiplicity+=signal.j[k].multiplicity;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return ranges;\n\t}\n\t\n\tmodule.exports.updateIntegrals = function(signals, options) {\n\t    var  factor = options.factor || 1 ;\n\t    var i;\n\t    if(options.sum) {\n\t        var nH = options.sum || 1;\n\t        var sumObserved=0;\n\t        for(i = 0; i < signals.length; i++) {\n\t            sumObserved += Math.round(signals[i].integral);\n\t        }\n\t        factor = nH/sumObserved;\n\t    }\n\t    for(i = 0; i < signals.length; i++) {\n\t        signals[i].integral *= factor;\n\t    }\n\t\n\t    return signals;\n\t}\n\t\n\tmodule.exports.nmrJ = function(Js, options){\n\t    var Jstring = \"\";\n\t    var opt = Object.assign({},{separator:\", \", nbDecimal:2}, options);\n\t    var j;\n\t    for(var i=0;i<Js.length;i++){\n\t        j = Js[i];\n\t        if (j.length>11) j+=opt.separator;\n\t        Jstring+=j.multiplicity+\" \"+j.coupling.toFixed(opt.nbDecimal);\n\t    }\n\t    return Jstring;\n\t}\n\t/**\n\t * This function converts an array of peaks [{x, y, width}] in a vector equally x,y vector\n\t * TODO This function is very general and should be placed somewhere else\n\t * @param peaks\n\t * @param opt\n\t * @returns {{x: Array, y: Array}}\n\t */\n\tmodule.exports.peak2Vector=function(peaks, opt){\n\t    var options = opt||{};\n\t    var from = options.from;\n\t    var to = options.to;\n\t    var nbPoints = options.nbPoints||16*1024;\n\t    var fnName = options.fnName||\"gaussian\";\n\t    var nWidth = options.nWidth || 4;\n\t\n\t    if(!from){\n\t        from = Number.MAX_VALUE;\n\t        for(var i=0;i<peaks.length;i++){\n\t            if(peaks[i].x-peaks[i].width*nWidth<from){\n\t                from = peaks[i].x-peaks[i].width*nWidth;\n\t            }\n\t        }\n\t    }\n\t\n\t    if(!to){\n\t        to = Number.MIN_VALUE;\n\t        for(var i=0;i<peaks.length;i++){\n\t            if(peaks[i].x+peaks[i].width*nWidth>to){\n\t                to = peaks[i].x+peaks[i].width*nWidth;\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    var x = new Array(nbPoints);\n\t    var y = new Array(nbPoints);\n\t    var dx = (to-from)/(nbPoints-1);\n\t    for(var i=0;i<nbPoints;i++){\n\t        x[i] = from+i*dx;\n\t        y[i] = 0;\n\t    }\n\t\n\t    var intensity = \"intensity\";\n\t    if(peaks[0].y){\n\t        intensity=\"y\";\n\t    }\n\t\n\t    for(var i=0;i<peaks.length;i++){\n\t        var peak = peaks[i];\n\t        if(peak.x>from && peak.x<to){\n\t            var index = Math.round((peak.x-from)/dx);\n\t            var w = Math.round(peak.width*nWidth/dx);\n\t            if(fnName==\"gaussian\"){\n\t                for(var j=index-w;j<index+w;j++){\n\t                    if(j>=0&&j<nbPoints){\n\t                        y[j]+=peak[intensity]*Math.exp(-0.5*Math.pow((peak.x-x[j])/(peak.width/2),2));\n\t                    }\n\t                }\n\t            }else{\n\t                var factor = peak[intensity]*Math.pow(peak.width,2)/4;\n\t                for(var j=index-w;j<index+w;j++){\n\t                    if(j>=0&&j<nbPoints){\n\t                        y[j]+=factor/(Math.pow(peak.x-x[j],2)+Math.pow(peak.width/2,2));\n\t\n\t                    }\n\t                }\n\t            }\n\t\n\t        }\n\t    }\n\t\n\t    return {x:x,y:y};\n\t}\n\t\n\tmodule.exports.range2Vector=function(ranges, opt){\n\t    return module.exports.peak2Vector(module.exports.range2Peaks(ranges), opt);\n\t}\n\t\n\tmodule.exports.range2Peaks = function(ranges){\n\t    var peaks = [];\n\t    for(var i=0;i<ranges.length;i++){\n\t        var range = ranges[i];\n\t        for(var j=0;j<range.signal.length;j++){\n\t            peaks=peaks.concat(range.signal[j].peak);\n\t        }\n\t    }\n\t    return peaks;\n\t}\n\t\n\tmodule.exports.toACS = function(spectrumIn, options){\n\t\n\t    var spectrum = JSON.parse(JSON.stringify(spectrumIn));\n\t\n\t    if(spectrum[0].delta1){//Old signals format\n\t        return old.toACS(spectrum, options);\n\t    }\n\t\n\t    spectrum = module.exports.update(spectrum);\n\t\n\t    acsString=\"\";\n\t    parenthesis=\"\";\n\t    spectro=\"\";\n\t    var solvent = null;\n\t    if(options&&options.solvent)\n\t        solvent = options.solvent;\n\t    if(options&&options.rangeForMultiplet!=undefined)\n\t        rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t    if(options&&options.ascending){\n\t        spectrum.sort(function(a,b){\n\t            return b.from- a.from\n\t        });\n\t    }\n\t    else{\n\t        spectrum.sort(function(a,b){\n\t            return a.from- b.from\n\t        });\n\t    }\n\t\n\t    spectrum.type=\"NMR SPEC\";\n\t    if (options&&options.nucleus==\"1H\") {\n\t        formatAcs_default(spectrum, false, 2, 1, solvent, options);\n\t    }\n\t    if (options&&options.nucleus==\"13C\") {\n\t        formatAcs_default(spectrum, false, 1, 0, solvent,options);\n\t    }\n\t\n\t    if (acsString.length>0) acsString+=\".\";\n\t\n\t    return acsString;\n\t}\n\t\n\tmodule.exports.toNMRSignal = function(acsString){\n\t    //TODO Create the function that reconstructs the signals from the ACS string\n\t    return null;\n\t}\n\t\n\t/*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n\t appendSeparator();\n\t appendSpectroInformation(spectra);\n\t if (spectra[\"peakLabels\"]) {\n\t var numberPeakLabels=spectra[\"peakLabels\"].length;\n\t var minIntensity= 9999999;\n\t var maxIntensity=-9999999;\n\t for (var i=0; i<numberPeakLabels; i++) {\n\t if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n\t if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n\t }\n\t for (var i=0; i<numberPeakLabels; i++) {\n\t if (ascending) {\n\t var peakLabel=spectra[\"peakLabels\"][i];\n\t } else {\n\t var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n\t }\n\t if (peakLabel) {\n\t appendSeparator();\n\t appendValue(peakLabel,decimalValue);\n\t if (smw) { // we need to add small / medium / strong\n\t if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n\t else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n\t else acsString+=\" (m)\";\n\t }\n\t }\n\t }\n\t }\n\t }*/\n\t\n\tfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent, options) {\n\t    appendSeparator();\n\t    appendSpectroInformation(spectra, solvent, options);\n\t    var numberSmartPeakLabels=spectra.length;\n\t    for (var i=0; i<numberSmartPeakLabels; i++) {\n\t        if (ascending) {\n\t            var signal=spectra[i];\n\t        } else {\n\t            var signal=spectra[numberSmartPeakLabels-i-1];\n\t        }\n\t        if (signal) {\n\t            appendSeparator();\n\t            appendDelta(signal,decimalValue);\n\t            appendParenthesis(signal,decimalJ);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendSpectroInformation(spectrum, solvent, options) {\n\t    if (spectrum.type==\"NMR SPEC\") {\n\t        if (options.nucleus) {\n\t            acsString+=formatNucleus(options.nucleus);\n\t        }\n\t        acsString+=\" NMR\";\n\t        if ((solvent) || (options.observe)) {\n\t            acsString+=\" (\";\n\t            if (options.observe) {\n\t                acsString+=(options.observe*1).toFixed(0)+\" MHz\";\n\t                if (solvent) acsString+=\", \";\n\t            }\n\t            if (solvent) {\n\t                acsString+=formatMF(solvent);\n\t            }\n\t            acsString+=\")\";\n\t        }\n\t        acsString+=\" δ \";\n\t    } else if (spectrum.type==\"IR\") {\n\t        acsString+=\" IR \";\n\t    } else if (spectrum.type==\"MASS\") {\n\t        acsString+=\" MASS \";\n\t    }\n\t}\n\t\n\tfunction appendDelta(line, nbDecimal) {\n\t    var startX = 0,stopX=0,delta1=0, asymmetric;\n\t    if(line.from){\n\t        if((typeof line.from)==\"string\"){\n\t            startX=parseFloat(line.from);\n\t        }\n\t        else\n\t            startX=line.from;\n\t    }\n\t    if(line.to){\n\t        if((typeof line.to)==\"string\"){\n\t            stopX=parseFloat(line.to);\n\t        }\n\t        else\n\t            stopX=line.to;\n\t    }\n\t    if(line.signal[0].delta){\n\t        if((typeof line.signal[0].delta)==\"string\"){\n\t            delta1=parseFloat(line.signal[0].delta);\n\t        }\n\t        else\n\t            delta1=line.signal[0].delta;\n\t    }\n\t    else{\n\t        asymmetric = true;\n\t    }\n\t    //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n\t    if (asymmetric===true||(line.signal[0].multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t        if (line.from&&line.to) {\n\t            if (startX<stopX) {\n\t                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t            } else {\n\t                acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n\t            }\n\t        } else {\n\t            if(line.signal[0].delta)\n\t                acsString+=\"?\";\n\t        }\n\t    }\n\t    else{\n\t        if(line.signal[0].delta)\n\t            acsString+=delta1.toFixed(nbDecimal);\n\t        else{\n\t            if(line.from&&line.to){\n\t                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendValue(line, nbDecimal) {\n\t    if (line.xPosition) {\n\t        acsString+=line.xPosition.toFixed(nbDecimal);\n\t    }\n\t}\n\t\n\tfunction appendParenthesis(line, nbDecimal) {\n\t    //console.log(\"appendParenthesis1\");\n\t    // need to add assignment - coupling - integration\n\t    parenthesis=\"\";\n\t    appendMultiplicity(line);\n\t    appendIntegration(line);\n\t    appendCoupling(line,nbDecimal);\n\t    appendAssignment(line);\n\t\n\t\n\t    if (parenthesis.length>0) {\n\t        acsString+=\" (\"+parenthesis+\")\";\n\t    }\n\t    //console.log(\"appendParenthesis2\");\n\t}\n\t\n\tfunction appendIntegration(line) {\n\t    if (line.pubIntegration) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubIntegration;\n\t    } else if (line.integral) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.integral.toFixed(0)+\" H\";\n\t    }\n\t}\n\t\n\tfunction appendAssignment(line) {\n\t    if (line.signal[0].pubAssignment) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=formatAssignment(line.signal[0].pubAssignment);\n\t    }\n\t    else{\n\t        if (line.signal[0].assignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.signal[0].assignment);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendMultiplicity(line) {\n\t    if (line.signal[0].pubMultiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubMultiplicity;\n\t    } else if (line.signal[0].multiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.signal[0].multiplicity;\n\t    }\n\t}\n\t\n\tfunction appendCoupling(line, nbDecimal) {\n\t    if (\"sm\".indexOf(line.signal[0].multiplicity) < 0\n\t            && line.signal[0].j && line.signal[0].j.length > 0) {\n\t        var Js = line.signal[0].j;\n\t        var j=\"<i>J</i> = \";\n\t        for (var i=0; i<Js.length; i++) {\n\t            var coupling=Js[i].coupling || 0;\n\t            if (j.length>11) j+=\", \";\n\t            j+=coupling.toFixed(nbDecimal);\n\t        }\n\t        appendParenthesisSeparator();\n\t        parenthesis+=j+\" Hz\";\n\t    }\n\t}\n\t\n\tfunction formatAssignment(assignment) {\n\t    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t    return assignment;\n\t}\n\t\n\tfunction formatMF(mf) {\n\t    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    return mf;\n\t}\n\t\n\tfunction formatNucleus(nucleus) {\n\t    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t    return nucleus;\n\t}\n\t\n\tfunction appendSeparator() {\n\t    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t        acsString+=\", \";\n\t    }\n\t}\n\t\n\tfunction appendParenthesisSeparator() {\n\t    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\t\n\tvar acsString=\"\";\n\tvar parenthesis=\"\";\n\tvar spectro=\"\";\n\tvar rangeForMultiplet=false;\n\t\n\tmodule.exports.toACS = function(spectrum, options){\n\t    acsString=\"\";\n\t    parenthesis=\"\";\n\t    spectro=\"\";\n\t    var solvent = null;\n\t    if(options&&options.solvent)\n\t        solvent = options.solvent;\n\t    if(options&&options.rangeForMultiplet!=undefined)\n\t        rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t    if(options&&options.ascending){\n\t        spectrum.sort(function(a,b){\n\t            return b.delta1- a.delta1\n\t        });\n\t    }\n\t    else{\n\t        spectrum.sort(function(a,b){\n\t            return a.delta1- b.delta1\n\t        });\n\t    }\n\t\n\t    //console.log(\"Range1: \"+options.rangeForMultiplet);\n\t\n\t    spectrum.type=\"NMR SPEC\";\n\t    if (spectrum[0][\"nucleus\"]==\"1H\") {\n\t        formatAcs_default(spectrum, false, 2, 1, solvent);\n\t    } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n\t        formatAcs_default(spectrum, false, 1, 0, solvent);\n\t    }\n\t\n\t    if (acsString.length>0) acsString+=\".\";\n\t\n\t    return acsString;\n\t}\n\t\n\tfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n\t    appendSeparator();\n\t    appendSpectroInformation(spectra, solvent);\n\t    var numberSmartPeakLabels=spectra.length;\n\t    for (var i=0; i<numberSmartPeakLabels; i++) {\n\t        if (ascending) {\n\t            var signal=spectra[i];\n\t        } else {\n\t            var signal=spectra[numberSmartPeakLabels-i-1];\n\t        }\n\t        if (signal) {\n\t            appendSeparator();\n\t            appendDelta(signal,decimalValue);\n\t            appendParenthesis(signal,decimalJ);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendSpectroInformation(spectrum, solvent) {\n\t    if (spectrum.type==\"NMR SPEC\") {\n\t        if (spectrum[0].nucleus) {\n\t            acsString+=formatNucleus(spectrum[0].nucleus);\n\t        }\n\t        acsString+=\" NMR\";\n\t        if ((solvent) || (spectrum[0].observe)) {\n\t            acsString+=\" (\";\n\t            if (spectrum[0].observe) {\n\t                acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n\t                if (solvent) acsString+=\", \";\n\t            }\n\t            if (solvent) {\n\t                acsString+=formatMF(solvent);\n\t            }\n\t            acsString+=\")\";\n\t        }\n\t        acsString+=\" δ \";\n\t    } else if (spectrum.type==\"IR\") {\n\t        acsString+=\" IR \";\n\t    } else if (spectrum.type==\"MASS\") {\n\t        acsString+=\" MASS \";\n\t    }\n\t}\n\t\n\tfunction appendDelta(line, nbDecimal) {\n\t    //console.log(line);\n\t    var startX = 0,stopX=0,delta1=0;\n\t    if(line.integralData.from) {\n\t        if ((typeof line.integralData.from) == \"string\") {\n\t            startX = parseFloat(line.integralData.from);\n\t        }\n\t        else\n\t            startX = line.integralData.from;\n\t    }\n\t    if(line.integralData.to){\n\t        if((typeof line.integralData.to)==\"string\"){\n\t            stopX=parseFloat(line.integralData.to);\n\t        }\n\t        else\n\t            stopX=line.integralData.to;\n\t    }\n\t    if(line.delta1){\n\t        if((typeof line.delta1)==\"string\"){\n\t            delta1=parseFloat(line.delta1);\n\t        }\n\t        else\n\t            delta1=line.delta1;\n\t\n\t    }\n\t    if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t        if (line.integralData.from&&line.integralData.to) {\n\t            if (startX<stopX) {\n\t                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t            } else {\n\t                acsString+=stopX.toFixed(nbDecimal)+\"-\"+sttotoFixed(nbDecimal);\n\t            }\n\t        } else {\n\t            if(line.delta1)\n\t                acsString+=delta1.toFixed(nbDecimal);\n\t        }\n\t    }\n\t    else{\n\t        if(line.delta1)\n\t            acsString+=delta1.toFixed(nbDecimal);\n\t        else{\n\t            if(line.integralData.from&&line.integralData.to){\n\t                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendValue(line, nbDecimal) {\n\t    if (line.xPosition) {\n\t        acsString+=line.xPosition.toFixed(nbDecimal);\n\t    }\n\t}\n\t\n\tfunction appendParenthesis(line, nbDecimal) {\n\t    // need to add assignment - coupling - integration\n\t    parenthesis=\"\";\n\t    appendMultiplicity(line);\n\t    appendIntegration(line);\n\t    appendCoupling(line,nbDecimal);\n\t    appendAssignment(line);\n\t\n\t\n\t    if (parenthesis.length>0) {\n\t        acsString+=\" (\"+parenthesis+\")\";\n\t    }\n\t}\n\t\n\tfunction appendIntegration(line) {\n\t    if (line.pubIntegration) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubIntegration;\n\t    } else if (line.integralData) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n\t    }\n\t}\n\t\n\tfunction appendAssignment(line) {\n\t    if (line.pubAssignment) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=formatAssignment(line.pubAssignment);\n\t    }\n\t    else{\n\t        if (line.assignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.assignment);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendMultiplicity(line) {\n\t    if (line.pubMultiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubMultiplicity;\n\t    } else if (line.multiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.multiplicity;\n\t    }\n\t}\n\t\n\tfunction appendCoupling(line, nbDecimal) {\n\t    if (line.nmrJs) {\n\t        var j=\"<i>J</i> = \";\n\t        for (var i=0; i<line.nmrJs.length; i++) {\n\t            var coupling=line.nmrJs[i].coupling;\n\t            if (j.length>11) j+=\", \";\n\t            j+=coupling.toFixed(nbDecimal);\n\t        }\n\t        appendParenthesisSeparator();\n\t        parenthesis+=j+\" Hz\";\n\t    }\n\t\n\t}\n\t\n\tfunction formatAssignment(assignment) {\n\t    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t    return assignment;\n\t}\n\t\n\tfunction formatMF(mf) {\n\t    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    return mf;\n\t}\n\t\n\tfunction formatNucleus(nucleus) {\n\t    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t    return nucleus;\n\t}\n\t\n\tfunction appendSeparator() {\n\t    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t        acsString+=\", \";\n\t    }\n\t}\n\t\n\tfunction appendParenthesisSeparator() {\n\t    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t}\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Created by acastillo on 8/17/16.\n\t */\n\t'use strict';\n\t\n\t//lineWidth in Hz frequency in MHz\n\tconst defaultOptions = {lineWidth:1, frequency: 400};\n\t\n\tmodule.exports.prediction2Ranges = function(predictions, opt){\n\t    const options = Object.assign({}, defaultOptions, opt);\n\t    //1. Collapse all the equivalent predictions\n\t    const nPredictions = predictions.length;\n\t    const ids = new Array(nPredictions);\n\t    var i, j, diaIDs, prediction, width, center, jc;\n\t    for(i = 0 ; i < nPredictions; i++) {\n\t        if(!ids[predictions[i].diaIDs[0]]) {\n\t            ids[predictions[i].diaIDs[0]] = [i]\n\t        }\n\t        else{\n\t            ids[predictions[i].diaIDs[0]].push(i);\n\t        }\n\t    }\n\t    const idsKeys = Object.keys(ids);\n\t    const result = new Array(idsKeys.length);\n\t\n\t    for(i = 0; i < idsKeys.length; i++) {\n\t        diaIDs = ids[idsKeys[i]];\n\t        prediction = predictions[diaIDs[0]];\n\t        width = 0;\n\t        jc = prediction.j;\n\t        if(jc){\n\t            for(j = 0; j < jc.length; j++) {\n\t                width+=jc[j].coupling;\n\t            }\n\t        }\n\t\n\t        width+= 2*options.lineWidth;//Add 2 times the spectral lineWidth\n\t\n\t        width/=options.frequency;\n\t\n\t        result[i] = {from: prediction.delta-width,\n\t                    to:prediction.delta+width,\n\t                    integral:1,\n\t                    signal:[ predictions[diaIDs[0]] ]};\n\t        for(j = 1; j < diaIDs.length; j++) {\n\t            result[i].signal.push(predictions[diaIDs[j]]);\n\t            result[i].integral++;\n\t        }\n\t    }\n\t    //2. Merge the overlaping ranges\n\t    for(i  =  0; i < result.length; i++) {\n\t        result[i]._highlight = result[i].signal[0].diaIDs;\n\t        center = (result[i].from + result[i].to)/2;\n\t        width = Math.abs(result[i].from - result[i].to);\n\t        for(j  = result.length - 1; j > i; j--) {\n\t            //Does it overlap?\n\t            if(Math.abs(center - (result[j].from + result[j].to)/2)\n\t                <= Math.abs(width + Math.abs(result[j].from - result[j].to))/2){\n\t                result[i].from = Math.min(result[i].from, result[j].from);\n\t                result[i].to = Math.max(result[i].to, result[j].to);\n\t                result[i].integral = result[i].integral + result[j].integral;\n\t                result[i]._highlight.push(result[j].signal[0].diaIDs[0]);\n\t                result.splice(j,1);\n\t                j = result.length - 1;\n\t                center = (result[i].from + result[i].to)/2;\n\t                width = Math.abs(result[i].from - result[i].to);\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** nmr-range.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0f5cf52f2f822662a89e\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\nvar old = require(\"./oldFormater\");\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports = require(\"./prediction2Range\");\n\nmodule.exports.update = function(ranges){\n    for (var i=0; i<ranges.length; i++){\n        var range = ranges[i];\n        for (var j=0; j<range.signal.length; j++){\n            var signal = range.signal[j];\n            if (signal.j && ! signal.multiplicity) {\n                signal.multiplicity = \"\";\n                for (var k=0; k<signal.j.length;k++){\n                    signal.multiplicity+=signal.j[k].multiplicity;\n                }\n            }\n        }\n    }\n\n    return ranges;\n}\n\nmodule.exports.updateIntegrals = function(signals, options) {\n    var  factor = options.factor || 1 ;\n    var i;\n    if(options.sum) {\n        var nH = options.sum || 1;\n        var sumObserved=0;\n        for(i = 0; i < signals.length; i++) {\n            sumObserved += Math.round(signals[i].integral);\n        }\n        factor = nH/sumObserved;\n    }\n    for(i = 0; i < signals.length; i++) {\n        signals[i].integral *= factor;\n    }\n\n    return signals;\n}\n\nmodule.exports.nmrJ = function(Js, options){\n    var Jstring = \"\";\n    var opt = Object.assign({},{separator:\", \", nbDecimal:2}, options);\n    var j;\n    for(var i=0;i<Js.length;i++){\n        j = Js[i];\n        if (j.length>11) j+=opt.separator;\n        Jstring+=j.multiplicity+\" \"+j.coupling.toFixed(opt.nbDecimal);\n    }\n    return Jstring;\n}\n/**\n * This function converts an array of peaks [{x, y, width}] in a vector equally x,y vector\n * TODO This function is very general and should be placed somewhere else\n * @param peaks\n * @param opt\n * @returns {{x: Array, y: Array}}\n */\nmodule.exports.peak2Vector=function(peaks, opt){\n    var options = opt||{};\n    var from = options.from;\n    var to = options.to;\n    var nbPoints = options.nbPoints||16*1024;\n    var fnName = options.fnName||\"gaussian\";\n    var nWidth = options.nWidth || 4;\n\n    if(!from){\n        from = Number.MAX_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x-peaks[i].width*nWidth<from){\n                from = peaks[i].x-peaks[i].width*nWidth;\n            }\n        }\n    }\n\n    if(!to){\n        to = Number.MIN_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x+peaks[i].width*nWidth>to){\n                to = peaks[i].x+peaks[i].width*nWidth;\n            }\n        }\n    }\n\n\n    var x = new Array(nbPoints);\n    var y = new Array(nbPoints);\n    var dx = (to-from)/(nbPoints-1);\n    for(var i=0;i<nbPoints;i++){\n        x[i] = from+i*dx;\n        y[i] = 0;\n    }\n\n    var intensity = \"intensity\";\n    if(peaks[0].y){\n        intensity=\"y\";\n    }\n\n    for(var i=0;i<peaks.length;i++){\n        var peak = peaks[i];\n        if(peak.x>from && peak.x<to){\n            var index = Math.round((peak.x-from)/dx);\n            var w = Math.round(peak.width*nWidth/dx);\n            if(fnName==\"gaussian\"){\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=peak[intensity]*Math.exp(-0.5*Math.pow((peak.x-x[j])/(peak.width/2),2));\n                    }\n                }\n            }else{\n                var factor = peak[intensity]*Math.pow(peak.width,2)/4;\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=factor/(Math.pow(peak.x-x[j],2)+Math.pow(peak.width/2,2));\n\n                    }\n                }\n            }\n\n        }\n    }\n\n    return {x:x,y:y};\n}\n\nmodule.exports.range2Vector=function(ranges, opt){\n    return module.exports.peak2Vector(module.exports.range2Peaks(ranges), opt);\n}\n\nmodule.exports.range2Peaks = function(ranges){\n    var peaks = [];\n    for(var i=0;i<ranges.length;i++){\n        var range = ranges[i];\n        for(var j=0;j<range.signal.length;j++){\n            peaks=peaks.concat(range.signal[j].peak);\n        }\n    }\n    return peaks;\n}\n\nmodule.exports.toACS = function(spectrumIn, options){\n\n    var spectrum = JSON.parse(JSON.stringify(spectrumIn));\n\n    if(spectrum[0].delta1){//Old signals format\n        return old.toACS(spectrum, options);\n    }\n\n    spectrum = module.exports.update(spectrum);\n\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.from- a.from\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.from- b.from\n        });\n    }\n\n    spectrum.type=\"NMR SPEC\";\n    if (options&&options.nucleus==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent, options);\n    }\n    if (options&&options.nucleus==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent,options);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nmodule.exports.toNMRSignal = function(acsString){\n    //TODO Create the function that reconstructs the signals from the ACS string\n    return null;\n}\n\n/*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n appendSeparator();\n appendSpectroInformation(spectra);\n if (spectra[\"peakLabels\"]) {\n var numberPeakLabels=spectra[\"peakLabels\"].length;\n var minIntensity= 9999999;\n var maxIntensity=-9999999;\n for (var i=0; i<numberPeakLabels; i++) {\n if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n }\n for (var i=0; i<numberPeakLabels; i++) {\n if (ascending) {\n var peakLabel=spectra[\"peakLabels\"][i];\n } else {\n var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n }\n if (peakLabel) {\n appendSeparator();\n appendValue(peakLabel,decimalValue);\n if (smw) { // we need to add small / medium / strong\n if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n else acsString+=\" (m)\";\n }\n }\n }\n }\n }*/\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent, options) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent, options);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent, options) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (options.nucleus) {\n            acsString+=formatNucleus(options.nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (options.observe)) {\n            acsString+=\" (\";\n            if (options.observe) {\n                acsString+=(options.observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    var startX = 0,stopX=0,delta1=0, asymmetric;\n    if(line.from){\n        if((typeof line.from)==\"string\"){\n            startX=parseFloat(line.from);\n        }\n        else\n            startX=line.from;\n    }\n    if(line.to){\n        if((typeof line.to)==\"string\"){\n            stopX=parseFloat(line.to);\n        }\n        else\n            stopX=line.to;\n    }\n    if(line.signal[0].delta){\n        if((typeof line.signal[0].delta)==\"string\"){\n            delta1=parseFloat(line.signal[0].delta);\n        }\n        else\n            delta1=line.signal[0].delta;\n    }\n    else{\n        asymmetric = true;\n    }\n    //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n    if (asymmetric===true||(line.signal[0].multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.from&&line.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n            }\n        } else {\n            if(line.signal[0].delta)\n                acsString+=\"?\";\n        }\n    }\n    else{\n        if(line.signal[0].delta)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.from&&line.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    //console.log(\"appendParenthesis1\");\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n    //console.log(\"appendParenthesis2\");\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integral) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integral.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.signal[0].pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.signal[0].pubAssignment);\n    }\n    else{\n        if (line.signal[0].assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.signal[0].assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.signal[0].pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.signal[0].multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.signal[0].multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (\"sm\".indexOf(line.signal[0].multiplicity) < 0\n            && line.signal[0].j && line.signal[0].j.length > 0) {\n        var Js = line.signal[0].j;\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<Js.length; i++) {\n            var coupling=Js[i].coupling || 0;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports.toACS = function(spectrum, options){\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.delta1- a.delta1\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.delta1- b.delta1\n        });\n    }\n\n    //console.log(\"Range1: \"+options.rangeForMultiplet);\n\n    spectrum.type=\"NMR SPEC\";\n    if (spectrum[0][\"nucleus\"]==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent);\n    } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (spectrum[0].nucleus) {\n            acsString+=formatNucleus(spectrum[0].nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (spectrum[0].observe)) {\n            acsString+=\" (\";\n            if (spectrum[0].observe) {\n                acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    //console.log(line);\n    var startX = 0,stopX=0,delta1=0;\n    if(line.integralData.from) {\n        if ((typeof line.integralData.from) == \"string\") {\n            startX = parseFloat(line.integralData.from);\n        }\n        else\n            startX = line.integralData.from;\n    }\n    if(line.integralData.to){\n        if((typeof line.integralData.to)==\"string\"){\n            stopX=parseFloat(line.integralData.to);\n        }\n        else\n            stopX=line.integralData.to;\n    }\n    if(line.delta1){\n        if((typeof line.delta1)==\"string\"){\n            delta1=parseFloat(line.delta1);\n        }\n        else\n            delta1=line.delta1;\n\n    }\n    if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.integralData.from&&line.integralData.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+sttotoFixed(nbDecimal);\n            }\n        } else {\n            if(line.delta1)\n                acsString+=delta1.toFixed(nbDecimal);\n        }\n    }\n    else{\n        if(line.delta1)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.integralData.from&&line.integralData.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integralData) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.pubAssignment);\n    }\n    else{\n        if (line.assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (line.nmrJs) {\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<line.nmrJs.length; i++) {\n            var coupling=line.nmrJs[i].coupling;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oldFormater.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/17/16.\n */\n'use strict';\n\n//lineWidth in Hz frequency in MHz\nconst defaultOptions = {lineWidth:1, frequency: 400};\n\nmodule.exports.prediction2Ranges = function(predictions, opt){\n    const options = Object.assign({}, defaultOptions, opt);\n    //1. Collapse all the equivalent predictions\n    const nPredictions = predictions.length;\n    const ids = new Array(nPredictions);\n    var i, j, diaIDs, prediction, width, center, jc;\n    for(i = 0 ; i < nPredictions; i++) {\n        if(!ids[predictions[i].diaIDs[0]]) {\n            ids[predictions[i].diaIDs[0]] = [i]\n        }\n        else{\n            ids[predictions[i].diaIDs[0]].push(i);\n        }\n    }\n    const idsKeys = Object.keys(ids);\n    const result = new Array(idsKeys.length);\n\n    for(i = 0; i < idsKeys.length; i++) {\n        diaIDs = ids[idsKeys[i]];\n        prediction = predictions[diaIDs[0]];\n        width = 0;\n        jc = prediction.j;\n        if(jc){\n            for(j = 0; j < jc.length; j++) {\n                width+=jc[j].coupling;\n            }\n        }\n\n        width+= 2*options.lineWidth;//Add 2 times the spectral lineWidth\n\n        width/=options.frequency;\n\n        result[i] = {from: prediction.delta-width,\n                    to:prediction.delta+width,\n                    integral:1,\n                    signal:[ predictions[diaIDs[0]] ]};\n        for(j = 1; j < diaIDs.length; j++) {\n            result[i].signal.push(predictions[diaIDs[j]]);\n            result[i].integral++;\n        }\n    }\n    //2. Merge the overlaping ranges\n    for(i  =  0; i < result.length; i++) {\n        result[i]._highlight = result[i].signal[0].diaIDs;\n        center = (result[i].from + result[i].to)/2;\n        width = Math.abs(result[i].from - result[i].to);\n        for(j  = result.length - 1; j > i; j--) {\n            //Does it overlap?\n            if(Math.abs(center - (result[j].from + result[j].to)/2)\n                <= Math.abs(width + Math.abs(result[j].from - result[j].to))/2){\n                result[i].from = Math.min(result[i].from, result[j].from);\n                result[i].to = Math.max(result[i].to, result[j].to);\n                result[i].integral = result[i].integral + result[j].integral;\n                result[i]._highlight.push(result[j].signal[0].diaIDs[0]);\n                result.splice(j,1);\n                j = result.length - 1;\n                center = (result[i].from + result[i].to)/2;\n                width = Math.abs(result[i].from - result[i].to);\n            }\n        }\n    }\n\n    return result;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/prediction2Range.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}