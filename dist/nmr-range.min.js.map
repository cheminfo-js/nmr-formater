{"version":3,"sources":["webpack:///nmr-range/webpack/universalModuleDefinition","webpack:///nmr-range/nmr-range.min.js","webpack:///nmr-range/webpack/bootstrap 5c0aa2db450bf0037844","webpack:///nmr-range/./src/index.js","webpack:///nmr-range/./src/oldFormater.js","webpack:///nmr-range/./src/prediction2Range.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","formatAcs_default","spectra","ascending","decimalValue","decimalJ","solvent","options","appendSeparator","appendSpectroInformation","numberSmartPeakLabels","length","i","signal","appendDelta","appendParenthesis","spectrum","type","nucleus","acsString","formatNucleus","observe","toFixed","formatMF","line","nbDecimal","asymmetric","startX","stopX","delta1","from","parseFloat","to","delta","multiplicity","rangeForMultiplet","parenthesis","appendMultiplicity","appendIntegration","appendCoupling","appendAssignment","pubIntegration","appendParenthesisSeparator","integral","pubAssignment","formatAssignment","assignment","pubMultiplicity","indexOf","j","Js","coupling","replace","mf","match","old","spectro","update","ranges","range","k","nmrJ","Jstring","opt","Object","assign","separator","peak2Vector","peaks","nbPoints","fnName","nWidth","Number","MAX_VALUE","x","width","MIN_VALUE","Array","y","dx","intensity","peak","index","Math","round","w","exp","pow","factor","range2Vector","range2Peaks","concat","toACS","spectrumIn","JSON","parse","stringify","undefined","sort","a","b","toNMRSignal","integralData","sttotoFixed","value","nmrJs","defaultOptions","lineWidth","frequency","prediction2Ranges","predictions","nPredictions","ids","diaIDs","prediction","center","jc","push","idsKeys","keys","result","_highlight","abs","min","max","splice"],"mappings":"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","file":"nmr-range.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrRange\"] = factory();\n\telse\n\t\troot[\"nmrRange\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrRange\"] = factory();\n\telse\n\t\troot[\"nmrRange\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\tvar old = __webpack_require__(1);\n\t\n\tvar acsString=\"\";\n\tvar parenthesis=\"\";\n\tvar spectro=\"\";\n\tvar rangeForMultiplet=false;\n\t\n\tmodule.exports = __webpack_require__(2);\n\t\n\tmodule.exports.update = function(ranges){\n\t    for (var i=0; i<ranges.length; i++){\n\t        var range = ranges[i];\n\t        for (var j=0; j<range.signal.length; j++){\n\t            var signal = range.signal[j];\n\t            if (signal.j && ! signal.multiplicity) {\n\t                signal.multiplicity = \"\";\n\t                for (var k=0; k<signal.j.length;k++){\n\t                    signal.multiplicity+=signal.j[k].multiplicity;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return ranges;\n\t}\n\t\n\tmodule.exports.nmrJ = function(Js, options){\n\t    var Jstring = \"\";\n\t    var opt = Object.assign({},{separator:\", \", nbDecimal:2}, options);\n\t    var j;\n\t    for(var i=0;i<Js.length;i++){\n\t        j = Js[i];\n\t        if (j.length>11) j+=opt.separator;\n\t        Jstring+=j.multiplicity+\" \"+j.coupling.toFixed(opt.nbDecimal);\n\t    }\n\t    return Jstring;\n\t}\n\t/**\n\t * This function converts an array of peaks [{x, y, width}] in a vector equally x,y vector\n\t * TODO This function is very general and should be placed somewhere else\n\t * @param peaks\n\t * @param opt\n\t * @returns {{x: Array, y: Array}}\n\t */\n\tmodule.exports.peak2Vector=function(peaks, opt){\n\t    var options = opt||{};\n\t    var from = options.from;\n\t    var to = options.to;\n\t    var nbPoints = options.nbPoints||16*1024;\n\t    var fnName = options.fnName||\"gaussian\";\n\t    var nWidth = options.nWidth || 4;\n\t\n\t    if(!from){\n\t        from = Number.MAX_VALUE;\n\t        for(var i=0;i<peaks.length;i++){\n\t            if(peaks[i].x-peaks[i].width*nWidth<from){\n\t                from = peaks[i].x-peaks[i].width*nWidth;\n\t            }\n\t        }\n\t    }\n\t\n\t    if(!to){\n\t        to = Number.MIN_VALUE;\n\t        for(var i=0;i<peaks.length;i++){\n\t            if(peaks[i].x+peaks[i].width*nWidth>to){\n\t                to = peaks[i].x+peaks[i].width*nWidth;\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    var x = new Array(nbPoints);\n\t    var y = new Array(nbPoints);\n\t    var dx = (to-from)/(nbPoints-1);\n\t    for(var i=0;i<nbPoints;i++){\n\t        x[i] = from+i*dx;\n\t        y[i] = 0;\n\t    }\n\t\n\t    var intensity = \"intensity\";\n\t    if(peaks[0].y){\n\t        intensity=\"y\";\n\t    }\n\t\n\t    for(var i=0;i<peaks.length;i++){\n\t        var peak = peaks[i];\n\t        if(peak.x>from && peak.x<to){\n\t            var index = Math.round((peak.x-from)/dx);\n\t            var w = Math.round(peak.width*nWidth/dx);\n\t            if(fnName==\"gaussian\"){\n\t                for(var j=index-w;j<index+w;j++){\n\t                    if(j>=0&&j<nbPoints){\n\t                        y[j]+=peak[intensity]*Math.exp(-0.5*Math.pow((peak.x-x[j])/(peak.width/2),2));\n\t                    }\n\t                }\n\t            }else{\n\t                var factor = peak[intensity]*Math.pow(peak.width,2)/4;\n\t                for(var j=index-w;j<index+w;j++){\n\t                    if(j>=0&&j<nbPoints){\n\t                        y[j]+=factor/(Math.pow(peak.x-x[j],2)+Math.pow(peak.width/2,2));\n\t\n\t                    }\n\t                }\n\t            }\n\t\n\t        }\n\t    }\n\t\n\t    return {x:x,y:y};\n\t}\n\t\n\tmodule.exports.range2Vector=function(ranges, opt){\n\t    return module.exports.peak2Vector(module.exports.range2Peaks(ranges), opt);\n\t}\n\t\n\tmodule.exports.range2Peaks = function(ranges){\n\t    var peaks = [];\n\t    for(var i=0;i<ranges.length;i++){\n\t        var range = ranges[i];\n\t        for(var j=0;j<range.signal.length;j++){\n\t            peaks=peaks.concat(range.signal[j].peak);\n\t        }\n\t    }\n\t    return peaks;\n\t}\n\t\n\tmodule.exports.toACS = function(spectrumIn, options){\n\t\n\t    var spectrum = JSON.parse(JSON.stringify(spectrumIn));\n\t\n\t    if(spectrum[0].delta1){//Old signals format\n\t        return old.toACS(spectrum, options);\n\t    }\n\t\n\t    spectrum = module.exports.update(spectrum);\n\t\n\t    acsString=\"\";\n\t    parenthesis=\"\";\n\t    spectro=\"\";\n\t    var solvent = null;\n\t    if(options&&options.solvent)\n\t        solvent = options.solvent;\n\t    if(options&&options.rangeForMultiplet!=undefined)\n\t        rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t    if(options&&options.ascending){\n\t        spectrum.sort(function(a,b){\n\t            return b.from- a.from\n\t        });\n\t    }\n\t    else{\n\t        spectrum.sort(function(a,b){\n\t            return a.from- b.from\n\t        });\n\t    }\n\t\n\t    spectrum.type=\"NMR SPEC\";\n\t    if (options&&options.nucleus==\"1H\") {\n\t        formatAcs_default(spectrum, false, 2, 1, solvent, options);\n\t    }\n\t    if (options&&options.nucleus==\"13C\") {\n\t        formatAcs_default(spectrum, false, 1, 0, solvent,options);\n\t    }\n\t\n\t    if (acsString.length>0) acsString+=\".\";\n\t\n\t    return acsString;\n\t}\n\t\n\tmodule.exports.toNMRSignal = function(acsString){\n\t    //TODO Create the function that reconstructs the signals from the ACS string\n\t    return null;\n\t}\n\t\n\t/*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n\t appendSeparator();\n\t appendSpectroInformation(spectra);\n\t if (spectra[\"peakLabels\"]) {\n\t var numberPeakLabels=spectra[\"peakLabels\"].length;\n\t var minIntensity= 9999999;\n\t var maxIntensity=-9999999;\n\t for (var i=0; i<numberPeakLabels; i++) {\n\t if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n\t if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n\t }\n\t for (var i=0; i<numberPeakLabels; i++) {\n\t if (ascending) {\n\t var peakLabel=spectra[\"peakLabels\"][i];\n\t } else {\n\t var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n\t }\n\t if (peakLabel) {\n\t appendSeparator();\n\t appendValue(peakLabel,decimalValue);\n\t if (smw) { // we need to add small / medium / strong\n\t if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n\t else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n\t else acsString+=\" (m)\";\n\t }\n\t }\n\t }\n\t }\n\t }*/\n\t\n\tfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent, options) {\n\t    appendSeparator();\n\t    appendSpectroInformation(spectra, solvent, options);\n\t    var numberSmartPeakLabels=spectra.length;\n\t    for (var i=0; i<numberSmartPeakLabels; i++) {\n\t        if (ascending) {\n\t            var signal=spectra[i];\n\t        } else {\n\t            var signal=spectra[numberSmartPeakLabels-i-1];\n\t        }\n\t        if (signal) {\n\t            appendSeparator();\n\t            appendDelta(signal,decimalValue);\n\t            appendParenthesis(signal,decimalJ);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendSpectroInformation(spectrum, solvent, options) {\n\t    if (spectrum.type==\"NMR SPEC\") {\n\t        if (options.nucleus) {\n\t            acsString+=formatNucleus(options.nucleus);\n\t        }\n\t        acsString+=\" NMR\";\n\t        if ((solvent) || (options.observe)) {\n\t            acsString+=\" (\";\n\t            if (options.observe) {\n\t                acsString+=(options.observe*1).toFixed(0)+\" MHz\";\n\t                if (solvent) acsString+=\", \";\n\t            }\n\t            if (solvent) {\n\t                acsString+=formatMF(solvent);\n\t            }\n\t            acsString+=\")\";\n\t        }\n\t        acsString+=\" δ \";\n\t    } else if (spectrum.type==\"IR\") {\n\t        acsString+=\" IR \";\n\t    } else if (spectrum.type==\"MASS\") {\n\t        acsString+=\" MASS \";\n\t    }\n\t}\n\t\n\tfunction appendDelta(line, nbDecimal) {\n\t    var startX = 0,stopX=0,delta1=0, asymmetric;\n\t    if(line.from){\n\t        if((typeof line.from)==\"string\"){\n\t            startX=parseFloat(line.from);\n\t        }\n\t        else\n\t            startX=line.from;\n\t    }\n\t    if(line.to){\n\t        if((typeof line.to)==\"string\"){\n\t            stopX=parseFloat(line.to);\n\t        }\n\t        else\n\t            stopX=line.to;\n\t    }\n\t    if(line.signal[0].delta){\n\t        if((typeof line.signal[0].delta)==\"string\"){\n\t            delta1=parseFloat(line.signal[0].delta);\n\t        }\n\t        else\n\t            delta1=line.signal[0].delta;\n\t    }\n\t    else{\n\t        asymmetric = true;\n\t    }\n\t    //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n\t    if (asymmetric===true||(line.signal[0].multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t        if (line.from&&line.to) {\n\t            if (startX<stopX) {\n\t                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t            } else {\n\t                acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n\t            }\n\t        } else {\n\t            if(line.signal[0].delta)\n\t                acsString+=\"?\";\n\t        }\n\t    }\n\t    else{\n\t        if(line.signal[0].delta)\n\t            acsString+=delta1.toFixed(nbDecimal);\n\t        else{\n\t            if(line.from&&line.to){\n\t                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendValue(line, nbDecimal) {\n\t    if (line.xPosition) {\n\t        acsString+=line.xPosition.toFixed(nbDecimal);\n\t    }\n\t}\n\t\n\tfunction appendParenthesis(line, nbDecimal) {\n\t    //console.log(\"appendParenthesis1\");\n\t    // need to add assignment - coupling - integration\n\t    parenthesis=\"\";\n\t    appendMultiplicity(line);\n\t    appendIntegration(line);\n\t    appendCoupling(line,nbDecimal);\n\t    appendAssignment(line);\n\t\n\t\n\t    if (parenthesis.length>0) {\n\t        acsString+=\" (\"+parenthesis+\")\";\n\t    }\n\t    //console.log(\"appendParenthesis2\");\n\t}\n\t\n\tfunction appendIntegration(line) {\n\t    if (line.pubIntegration) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubIntegration;\n\t    } else if (line.integral) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.integral.toFixed(0)+\" H\";\n\t    }\n\t}\n\t\n\tfunction appendAssignment(line) {\n\t    if (line.signal[0].pubAssignment) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=formatAssignment(line.signal[0].pubAssignment);\n\t    }\n\t    else{\n\t        if (line.signal[0].assignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.signal[0].assignment);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendMultiplicity(line) {\n\t    if (line.signal[0].pubMultiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubMultiplicity;\n\t    } else if (line.signal[0].multiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.signal[0].multiplicity;\n\t    }\n\t}\n\t\n\tfunction appendCoupling(line, nbDecimal) {\n\t    if (\"sm\".indexOf(line.signal[0].multiplicity) < 0\n\t            && line.signal[0].j && line.signal[0].j.length > 0) {\n\t        var Js = line.signal[0].j;\n\t        var j=\"<i>J</i> = \";\n\t        for (var i=0; i<Js.length; i++) {\n\t            var coupling=Js[i].coupling || 0;\n\t            if (j.length>11) j+=\", \";\n\t            j+=coupling.toFixed(nbDecimal);\n\t        }\n\t        appendParenthesisSeparator();\n\t        parenthesis+=j+\" Hz\";\n\t    }\n\t}\n\t\n\tfunction formatAssignment(assignment) {\n\t    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t    return assignment;\n\t}\n\t\n\tfunction formatMF(mf) {\n\t    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    return mf;\n\t}\n\t\n\tfunction formatNucleus(nucleus) {\n\t    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t    return nucleus;\n\t}\n\t\n\tfunction appendSeparator() {\n\t    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t        acsString+=\", \";\n\t    }\n\t}\n\t\n\tfunction appendParenthesisSeparator() {\n\t    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\t\n\tvar acsString=\"\";\n\tvar parenthesis=\"\";\n\tvar spectro=\"\";\n\tvar rangeForMultiplet=false;\n\t\n\tmodule.exports.toACS = function(spectrum, options){\n\t    acsString=\"\";\n\t    parenthesis=\"\";\n\t    spectro=\"\";\n\t    var solvent = null;\n\t    if(options&&options.solvent)\n\t        solvent = options.solvent;\n\t    if(options&&options.rangeForMultiplet!=undefined)\n\t        rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t    if(options&&options.ascending){\n\t        spectrum.sort(function(a,b){\n\t            return b.delta1- a.delta1\n\t        });\n\t    }\n\t    else{\n\t        spectrum.sort(function(a,b){\n\t            return a.delta1- b.delta1\n\t        });\n\t    }\n\t\n\t    //console.log(\"Range1: \"+options.rangeForMultiplet);\n\t\n\t    spectrum.type=\"NMR SPEC\";\n\t    if (spectrum[0][\"nucleus\"]==\"1H\") {\n\t        formatAcs_default(spectrum, false, 2, 1, solvent);\n\t    } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n\t        formatAcs_default(spectrum, false, 1, 0, solvent);\n\t    }\n\t\n\t    if (acsString.length>0) acsString+=\".\";\n\t\n\t    return acsString;\n\t}\n\t\n\tfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n\t    appendSeparator();\n\t    appendSpectroInformation(spectra, solvent);\n\t    var numberSmartPeakLabels=spectra.length;\n\t    for (var i=0; i<numberSmartPeakLabels; i++) {\n\t        if (ascending) {\n\t            var signal=spectra[i];\n\t        } else {\n\t            var signal=spectra[numberSmartPeakLabels-i-1];\n\t        }\n\t        if (signal) {\n\t            appendSeparator();\n\t            appendDelta(signal,decimalValue);\n\t            appendParenthesis(signal,decimalJ);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendSpectroInformation(spectrum, solvent) {\n\t    if (spectrum.type==\"NMR SPEC\") {\n\t        if (spectrum[0].nucleus) {\n\t            acsString+=formatNucleus(spectrum[0].nucleus);\n\t        }\n\t        acsString+=\" NMR\";\n\t        if ((solvent) || (spectrum[0].observe)) {\n\t            acsString+=\" (\";\n\t            if (spectrum[0].observe) {\n\t                acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n\t                if (solvent) acsString+=\", \";\n\t            }\n\t            if (solvent) {\n\t                acsString+=formatMF(solvent);\n\t            }\n\t            acsString+=\")\";\n\t        }\n\t        acsString+=\" δ \";\n\t    } else if (spectrum.type==\"IR\") {\n\t        acsString+=\" IR \";\n\t    } else if (spectrum.type==\"MASS\") {\n\t        acsString+=\" MASS \";\n\t    }\n\t}\n\t\n\tfunction appendDelta(line, nbDecimal) {\n\t    //console.log(line);\n\t    var startX = 0,stopX=0,delta1=0;\n\t    if(line.integralData.from) {\n\t        if ((typeof line.integralData.from) == \"string\") {\n\t            startX = parseFloat(line.integralData.from);\n\t        }\n\t        else\n\t            startX = line.integralData.from;\n\t    }\n\t    if(line.integralData.to){\n\t        if((typeof line.integralData.to)==\"string\"){\n\t            stopX=parseFloat(line.integralData.to);\n\t        }\n\t        else\n\t            stopX=line.integralData.to;\n\t    }\n\t    if(line.delta1){\n\t        if((typeof line.delta1)==\"string\"){\n\t            delta1=parseFloat(line.delta1);\n\t        }\n\t        else\n\t            delta1=line.delta1;\n\t\n\t    }\n\t    if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t        if (line.integralData.from&&line.integralData.to) {\n\t            if (startX<stopX) {\n\t                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t            } else {\n\t                acsString+=stopX.toFixed(nbDecimal)+\"-\"+sttotoFixed(nbDecimal);\n\t            }\n\t        } else {\n\t            if(line.delta1)\n\t                acsString+=delta1.toFixed(nbDecimal);\n\t        }\n\t    }\n\t    else{\n\t        if(line.delta1)\n\t            acsString+=delta1.toFixed(nbDecimal);\n\t        else{\n\t            if(line.integralData.from&&line.integralData.to){\n\t                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendValue(line, nbDecimal) {\n\t    if (line.xPosition) {\n\t        acsString+=line.xPosition.toFixed(nbDecimal);\n\t    }\n\t}\n\t\n\tfunction appendParenthesis(line, nbDecimal) {\n\t    // need to add assignment - coupling - integration\n\t    parenthesis=\"\";\n\t    appendMultiplicity(line);\n\t    appendIntegration(line);\n\t    appendCoupling(line,nbDecimal);\n\t    appendAssignment(line);\n\t\n\t\n\t    if (parenthesis.length>0) {\n\t        acsString+=\" (\"+parenthesis+\")\";\n\t    }\n\t}\n\t\n\tfunction appendIntegration(line) {\n\t    if (line.pubIntegration) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubIntegration;\n\t    } else if (line.integralData) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n\t    }\n\t}\n\t\n\tfunction appendAssignment(line) {\n\t    if (line.pubAssignment) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=formatAssignment(line.pubAssignment);\n\t    }\n\t    else{\n\t        if (line.assignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.assignment);\n\t        }\n\t    }\n\t}\n\t\n\tfunction appendMultiplicity(line) {\n\t    if (line.pubMultiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.pubMultiplicity;\n\t    } else if (line.multiplicity) {\n\t        appendParenthesisSeparator();\n\t        parenthesis+=line.multiplicity;\n\t    }\n\t}\n\t\n\tfunction appendCoupling(line, nbDecimal) {\n\t    if (line.nmrJs) {\n\t        var j=\"<i>J</i> = \";\n\t        for (var i=0; i<line.nmrJs.length; i++) {\n\t            var coupling=line.nmrJs[i].coupling;\n\t            if (j.length>11) j+=\", \";\n\t            j+=coupling.toFixed(nbDecimal);\n\t        }\n\t        appendParenthesisSeparator();\n\t        parenthesis+=j+\" Hz\";\n\t    }\n\t\n\t}\n\t\n\tfunction formatAssignment(assignment) {\n\t    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t    return assignment;\n\t}\n\t\n\tfunction formatMF(mf) {\n\t    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t    return mf;\n\t}\n\t\n\tfunction formatNucleus(nucleus) {\n\t    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t    return nucleus;\n\t}\n\t\n\tfunction appendSeparator() {\n\t    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t        acsString+=\", \";\n\t    }\n\t}\n\t\n\tfunction appendParenthesisSeparator() {\n\t    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t}\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Created by acastillo on 8/17/16.\n\t */\n\t'use strict';\n\t\n\t//lineWidth in Hz frequency in MHz\n\tconst defaultOptions = {lineWidth:1, frequency: 400};\n\t\n\tmodule.exports.prediction2Ranges = function(predictions, opt){\n\t    const options = Object.assign({}, defaultOptions, opt);\n\t    //1. Collapse all the equivalent predictions\n\t    const nPredictions = predictions.length;\n\t    const ids = new Array(nPredictions);\n\t    var i, j, diaIDs, prediction, width, center, jc;\n\t    for(i = 0 ; i < nPredictions; i++) {\n\t        if(!ids[predictions[i].diaIDs[0]]) {\n\t            ids[predictions[i].diaIDs[0]] = [i]\n\t        }\n\t        else{\n\t            ids[predictions[i].diaIDs[0]].push(i);\n\t        }\n\t    }\n\t    const idsKeys = Object.keys(ids);\n\t    const result = new Array(idsKeys.length);\n\t\n\t    for(i = 0; i < idsKeys.length; i++) {\n\t        diaIDs = ids[idsKeys[i]];\n\t        prediction = predictions[diaIDs[0]];\n\t        width = 0;\n\t        jc = prediction.j;\n\t        if(jc){\n\t            for(j = 0; j < jc.length; j++) {\n\t                width+=jc[j].coupling;\n\t            }\n\t        }\n\t\n\t        width+= 2*options.lineWidth;//Add 2 times the spectral lineWidth\n\t\n\t        width/=options.frequency;\n\t\n\t        result[i] = {from: prediction.delta-width,\n\t                    to:prediction.delta+width,\n\t                    integral:1,\n\t                    signal:[ predictions[diaIDs[0]] ]};\n\t        for(j = 1; j < diaIDs.length; j++) {\n\t            result[i].signal.push(predictions[diaIDs[j]]);\n\t            result[i].integral++;\n\t        }\n\t    }\n\t    //2. Merge the overlaping ranges\n\t    for(i  =  0; i < result.length; i++) {\n\t        result[i]._highlight = result[i].signal[0].diaIDs;\n\t        center = (result[i].from + result[i].to)/2;\n\t        width = Math.abs(result[i].from - result[i].to);\n\t        for(j  = result.length - 1; j > i; j--) {\n\t            //Does it overlap?\n\t            if(Math.abs(center - (result[j].from + result[j].to)/2)\n\t                <= Math.abs(width + Math.abs(result[j].from - result[j].to))/2){\n\t                result[i].from = Math.min(result[i].from, result[j].from);\n\t                result[i].to = Math.max(result[i].to, result[j].to);\n\t                result[i].integral = result[i].integral + result[j].integral;\n\t                result[i]._highlight.push(result[j].signal[0].diaIDs[0]);\n\t                result.splice(j,1);\n\t                j = result.length - 1;\n\t                center = (result[i].from + result[i].to)/2;\n\t                width = Math.abs(result[i].from - result[i].to);\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** nmr-range.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5c0aa2db450bf0037844\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\nvar old = require(\"./oldFormater\");\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports = require(\"./prediction2Range\");\n\nmodule.exports.update = function(ranges){\n    for (var i=0; i<ranges.length; i++){\n        var range = ranges[i];\n        for (var j=0; j<range.signal.length; j++){\n            var signal = range.signal[j];\n            if (signal.j && ! signal.multiplicity) {\n                signal.multiplicity = \"\";\n                for (var k=0; k<signal.j.length;k++){\n                    signal.multiplicity+=signal.j[k].multiplicity;\n                }\n            }\n        }\n    }\n\n    return ranges;\n}\n\nmodule.exports.nmrJ = function(Js, options){\n    var Jstring = \"\";\n    var opt = Object.assign({},{separator:\", \", nbDecimal:2}, options);\n    var j;\n    for(var i=0;i<Js.length;i++){\n        j = Js[i];\n        if (j.length>11) j+=opt.separator;\n        Jstring+=j.multiplicity+\" \"+j.coupling.toFixed(opt.nbDecimal);\n    }\n    return Jstring;\n}\n/**\n * This function converts an array of peaks [{x, y, width}] in a vector equally x,y vector\n * TODO This function is very general and should be placed somewhere else\n * @param peaks\n * @param opt\n * @returns {{x: Array, y: Array}}\n */\nmodule.exports.peak2Vector=function(peaks, opt){\n    var options = opt||{};\n    var from = options.from;\n    var to = options.to;\n    var nbPoints = options.nbPoints||16*1024;\n    var fnName = options.fnName||\"gaussian\";\n    var nWidth = options.nWidth || 4;\n\n    if(!from){\n        from = Number.MAX_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x-peaks[i].width*nWidth<from){\n                from = peaks[i].x-peaks[i].width*nWidth;\n            }\n        }\n    }\n\n    if(!to){\n        to = Number.MIN_VALUE;\n        for(var i=0;i<peaks.length;i++){\n            if(peaks[i].x+peaks[i].width*nWidth>to){\n                to = peaks[i].x+peaks[i].width*nWidth;\n            }\n        }\n    }\n\n\n    var x = new Array(nbPoints);\n    var y = new Array(nbPoints);\n    var dx = (to-from)/(nbPoints-1);\n    for(var i=0;i<nbPoints;i++){\n        x[i] = from+i*dx;\n        y[i] = 0;\n    }\n\n    var intensity = \"intensity\";\n    if(peaks[0].y){\n        intensity=\"y\";\n    }\n\n    for(var i=0;i<peaks.length;i++){\n        var peak = peaks[i];\n        if(peak.x>from && peak.x<to){\n            var index = Math.round((peak.x-from)/dx);\n            var w = Math.round(peak.width*nWidth/dx);\n            if(fnName==\"gaussian\"){\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=peak[intensity]*Math.exp(-0.5*Math.pow((peak.x-x[j])/(peak.width/2),2));\n                    }\n                }\n            }else{\n                var factor = peak[intensity]*Math.pow(peak.width,2)/4;\n                for(var j=index-w;j<index+w;j++){\n                    if(j>=0&&j<nbPoints){\n                        y[j]+=factor/(Math.pow(peak.x-x[j],2)+Math.pow(peak.width/2,2));\n\n                    }\n                }\n            }\n\n        }\n    }\n\n    return {x:x,y:y};\n}\n\nmodule.exports.range2Vector=function(ranges, opt){\n    return module.exports.peak2Vector(module.exports.range2Peaks(ranges), opt);\n}\n\nmodule.exports.range2Peaks = function(ranges){\n    var peaks = [];\n    for(var i=0;i<ranges.length;i++){\n        var range = ranges[i];\n        for(var j=0;j<range.signal.length;j++){\n            peaks=peaks.concat(range.signal[j].peak);\n        }\n    }\n    return peaks;\n}\n\nmodule.exports.toACS = function(spectrumIn, options){\n\n    var spectrum = JSON.parse(JSON.stringify(spectrumIn));\n\n    if(spectrum[0].delta1){//Old signals format\n        return old.toACS(spectrum, options);\n    }\n\n    spectrum = module.exports.update(spectrum);\n\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.from- a.from\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.from- b.from\n        });\n    }\n\n    spectrum.type=\"NMR SPEC\";\n    if (options&&options.nucleus==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent, options);\n    }\n    if (options&&options.nucleus==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent,options);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nmodule.exports.toNMRSignal = function(acsString){\n    //TODO Create the function that reconstructs the signals from the ACS string\n    return null;\n}\n\n/*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n appendSeparator();\n appendSpectroInformation(spectra);\n if (spectra[\"peakLabels\"]) {\n var numberPeakLabels=spectra[\"peakLabels\"].length;\n var minIntensity= 9999999;\n var maxIntensity=-9999999;\n for (var i=0; i<numberPeakLabels; i++) {\n if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n }\n for (var i=0; i<numberPeakLabels; i++) {\n if (ascending) {\n var peakLabel=spectra[\"peakLabels\"][i];\n } else {\n var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n }\n if (peakLabel) {\n appendSeparator();\n appendValue(peakLabel,decimalValue);\n if (smw) { // we need to add small / medium / strong\n if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n else acsString+=\" (m)\";\n }\n }\n }\n }\n }*/\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent, options) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent, options);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent, options) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (options.nucleus) {\n            acsString+=formatNucleus(options.nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (options.observe)) {\n            acsString+=\" (\";\n            if (options.observe) {\n                acsString+=(options.observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    var startX = 0,stopX=0,delta1=0, asymmetric;\n    if(line.from){\n        if((typeof line.from)==\"string\"){\n            startX=parseFloat(line.from);\n        }\n        else\n            startX=line.from;\n    }\n    if(line.to){\n        if((typeof line.to)==\"string\"){\n            stopX=parseFloat(line.to);\n        }\n        else\n            stopX=line.to;\n    }\n    if(line.signal[0].delta){\n        if((typeof line.signal[0].delta)==\"string\"){\n            delta1=parseFloat(line.signal[0].delta);\n        }\n        else\n            delta1=line.signal[0].delta;\n    }\n    else{\n        asymmetric = true;\n    }\n    //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n    if (asymmetric===true||(line.signal[0].multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.from&&line.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n            }\n        } else {\n            if(line.signal[0].delta)\n                acsString+=\"?\";\n        }\n    }\n    else{\n        if(line.signal[0].delta)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.from&&line.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    //console.log(\"appendParenthesis1\");\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n    //console.log(\"appendParenthesis2\");\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integral) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integral.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.signal[0].pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.signal[0].pubAssignment);\n    }\n    else{\n        if (line.signal[0].assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.signal[0].assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.signal[0].pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.signal[0].multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.signal[0].multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (\"sm\".indexOf(line.signal[0].multiplicity) < 0\n            && line.signal[0].j && line.signal[0].j.length > 0) {\n        var Js = line.signal[0].j;\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<Js.length; i++) {\n            var coupling=Js[i].coupling || 0;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\n\nvar acsString=\"\";\nvar parenthesis=\"\";\nvar spectro=\"\";\nvar rangeForMultiplet=false;\n\nmodule.exports.toACS = function(spectrum, options){\n    acsString=\"\";\n    parenthesis=\"\";\n    spectro=\"\";\n    var solvent = null;\n    if(options&&options.solvent)\n        solvent = options.solvent;\n    if(options&&options.rangeForMultiplet!=undefined)\n        rangeForMultiplet = options.rangeForMultiplet;\n\n    if(options&&options.ascending){\n        spectrum.sort(function(a,b){\n            return b.delta1- a.delta1\n        });\n    }\n    else{\n        spectrum.sort(function(a,b){\n            return a.delta1- b.delta1\n        });\n    }\n\n    //console.log(\"Range1: \"+options.rangeForMultiplet);\n\n    spectrum.type=\"NMR SPEC\";\n    if (spectrum[0][\"nucleus\"]==\"1H\") {\n        formatAcs_default(spectrum, false, 2, 1, solvent);\n    } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n        formatAcs_default(spectrum, false, 1, 0, solvent);\n    }\n\n    if (acsString.length>0) acsString+=\".\";\n\n    return acsString;\n}\n\nfunction formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n    appendSeparator();\n    appendSpectroInformation(spectra, solvent);\n    var numberSmartPeakLabels=spectra.length;\n    for (var i=0; i<numberSmartPeakLabels; i++) {\n        if (ascending) {\n            var signal=spectra[i];\n        } else {\n            var signal=spectra[numberSmartPeakLabels-i-1];\n        }\n        if (signal) {\n            appendSeparator();\n            appendDelta(signal,decimalValue);\n            appendParenthesis(signal,decimalJ);\n        }\n    }\n}\n\nfunction appendSpectroInformation(spectrum, solvent) {\n    if (spectrum.type==\"NMR SPEC\") {\n        if (spectrum[0].nucleus) {\n            acsString+=formatNucleus(spectrum[0].nucleus);\n        }\n        acsString+=\" NMR\";\n        if ((solvent) || (spectrum[0].observe)) {\n            acsString+=\" (\";\n            if (spectrum[0].observe) {\n                acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n                if (solvent) acsString+=\", \";\n            }\n            if (solvent) {\n                acsString+=formatMF(solvent);\n            }\n            acsString+=\")\";\n        }\n        acsString+=\" δ \";\n    } else if (spectrum.type==\"IR\") {\n        acsString+=\" IR \";\n    } else if (spectrum.type==\"MASS\") {\n        acsString+=\" MASS \";\n    }\n}\n\nfunction appendDelta(line, nbDecimal) {\n    //console.log(line);\n    var startX = 0,stopX=0,delta1=0;\n    if(line.integralData.from) {\n        if ((typeof line.integralData.from) == \"string\") {\n            startX = parseFloat(line.integralData.from);\n        }\n        else\n            startX = line.integralData.from;\n    }\n    if(line.integralData.to){\n        if((typeof line.integralData.to)==\"string\"){\n            stopX=parseFloat(line.integralData.to);\n        }\n        else\n            stopX=line.integralData.to;\n    }\n    if(line.delta1){\n        if((typeof line.delta1)==\"string\"){\n            delta1=parseFloat(line.delta1);\n        }\n        else\n            delta1=line.delta1;\n\n    }\n    if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n        if (line.integralData.from&&line.integralData.to) {\n            if (startX<stopX) {\n                acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n            } else {\n                acsString+=stopX.toFixed(nbDecimal)+\"-\"+sttotoFixed(nbDecimal);\n            }\n        } else {\n            if(line.delta1)\n                acsString+=delta1.toFixed(nbDecimal);\n        }\n    }\n    else{\n        if(line.delta1)\n            acsString+=delta1.toFixed(nbDecimal);\n        else{\n            if(line.integralData.from&&line.integralData.to){\n                acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n            }\n        }\n    }\n}\n\nfunction appendValue(line, nbDecimal) {\n    if (line.xPosition) {\n        acsString+=line.xPosition.toFixed(nbDecimal);\n    }\n}\n\nfunction appendParenthesis(line, nbDecimal) {\n    // need to add assignment - coupling - integration\n    parenthesis=\"\";\n    appendMultiplicity(line);\n    appendIntegration(line);\n    appendCoupling(line,nbDecimal);\n    appendAssignment(line);\n\n\n    if (parenthesis.length>0) {\n        acsString+=\" (\"+parenthesis+\")\";\n    }\n}\n\nfunction appendIntegration(line) {\n    if (line.pubIntegration) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubIntegration;\n    } else if (line.integralData) {\n        appendParenthesisSeparator();\n        parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n    }\n}\n\nfunction appendAssignment(line) {\n    if (line.pubAssignment) {\n        appendParenthesisSeparator();\n        parenthesis+=formatAssignment(line.pubAssignment);\n    }\n    else{\n        if (line.assignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.assignment);\n        }\n    }\n}\n\nfunction appendMultiplicity(line) {\n    if (line.pubMultiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.pubMultiplicity;\n    } else if (line.multiplicity) {\n        appendParenthesisSeparator();\n        parenthesis+=line.multiplicity;\n    }\n}\n\nfunction appendCoupling(line, nbDecimal) {\n    if (line.nmrJs) {\n        var j=\"<i>J</i> = \";\n        for (var i=0; i<line.nmrJs.length; i++) {\n            var coupling=line.nmrJs[i].coupling;\n            if (j.length>11) j+=\", \";\n            j+=coupling.toFixed(nbDecimal);\n        }\n        appendParenthesisSeparator();\n        parenthesis+=j+\" Hz\";\n    }\n\n}\n\nfunction formatAssignment(assignment) {\n    assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n    return assignment;\n}\n\nfunction formatMF(mf) {\n    mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n    return mf;\n}\n\nfunction formatNucleus(nucleus) {\n    nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n    return nucleus;\n}\n\nfunction appendSeparator() {\n    if ((acsString.length>0) && (! acsString.match(/ $/))) {\n        acsString+=\", \";\n    }\n}\n\nfunction appendParenthesisSeparator() {\n    if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oldFormater.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/17/16.\n */\n'use strict';\n\n//lineWidth in Hz frequency in MHz\nconst defaultOptions = {lineWidth:1, frequency: 400};\n\nmodule.exports.prediction2Ranges = function(predictions, opt){\n    const options = Object.assign({}, defaultOptions, opt);\n    //1. Collapse all the equivalent predictions\n    const nPredictions = predictions.length;\n    const ids = new Array(nPredictions);\n    var i, j, diaIDs, prediction, width, center, jc;\n    for(i = 0 ; i < nPredictions; i++) {\n        if(!ids[predictions[i].diaIDs[0]]) {\n            ids[predictions[i].diaIDs[0]] = [i]\n        }\n        else{\n            ids[predictions[i].diaIDs[0]].push(i);\n        }\n    }\n    const idsKeys = Object.keys(ids);\n    const result = new Array(idsKeys.length);\n\n    for(i = 0; i < idsKeys.length; i++) {\n        diaIDs = ids[idsKeys[i]];\n        prediction = predictions[diaIDs[0]];\n        width = 0;\n        jc = prediction.j;\n        if(jc){\n            for(j = 0; j < jc.length; j++) {\n                width+=jc[j].coupling;\n            }\n        }\n\n        width+= 2*options.lineWidth;//Add 2 times the spectral lineWidth\n\n        width/=options.frequency;\n\n        result[i] = {from: prediction.delta-width,\n                    to:prediction.delta+width,\n                    integral:1,\n                    signal:[ predictions[diaIDs[0]] ]};\n        for(j = 1; j < diaIDs.length; j++) {\n            result[i].signal.push(predictions[diaIDs[j]]);\n            result[i].integral++;\n        }\n    }\n    //2. Merge the overlaping ranges\n    for(i  =  0; i < result.length; i++) {\n        result[i]._highlight = result[i].signal[0].diaIDs;\n        center = (result[i].from + result[i].to)/2;\n        width = Math.abs(result[i].from - result[i].to);\n        for(j  = result.length - 1; j > i; j--) {\n            //Does it overlap?\n            if(Math.abs(center - (result[j].from + result[j].to)/2)\n                <= Math.abs(width + Math.abs(result[j].from - result[j].to))/2){\n                result[i].from = Math.min(result[i].from, result[j].from);\n                result[i].to = Math.max(result[i].to, result[j].to);\n                result[i].integral = result[i].integral + result[j].integral;\n                result[i]._highlight.push(result[j].signal[0].diaIDs[0]);\n                result.splice(j,1);\n                j = result.length - 1;\n                center = (result[i].from + result[i].to)/2;\n                width = Math.abs(result[i].from - result[i].to);\n            }\n        }\n    }\n\n    return result;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/prediction2Range.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}